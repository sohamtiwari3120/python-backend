{
  "problem":  "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.",
  "solution":  "  def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \n        lower_bound = self.findBound(nums, target, True)\n        if (lower_bound == -1):\n            return [-1, -1]\n        \n        upper_bound = self.findBound(nums, target, False)\n        \n        return [lower_bound, upper_bound]\n        \n    def findBound(self, nums: List[int], target: int, isFirst: bool) -> int:\n        \n        N = len(nums)\n        begin, end = 0, N - 1\n        while begin <= end:\n            mid = int((begin + end) / 2)    \n            \n            if nums[mid] == target:\n                \n                if isFirst:\n                    if mid == begin or nums[mid - 1] < target:\n                        return mid\n\n                    end = mid - 1\n                else:\n                    \n                    if mid == end or nums[mid + 1] > target:\n                        return mid\n                    \n                    begin = mid + 1\n            \n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                begin = mid + 1\n        \n        return -1" ,
  "states": [
    {
     "Current Code": "    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        res = [-1, -1]\n        found_target = False\n        for i, num in enumerate(nums): \n            if num == target and not found_target: \n                res[0] = i\n                res[1] = i\n            if found_target and num != target: \n                res[1] = i - 1\n        return res \n            ",
      "Transcript": "Student: Well, okay so the problem says to find the indices of the first and last position\nof an element in a sorted array is...\nStudent: I guess I'd first start with simply using a for loop and checking for the target value,\nas soon as we hit one then record the index as the start and end value. When we see a number after\nthis that is different then the end value is set to the previous start"
    },
        {
     "Current Code": "    def searchRange(self, nums, target):\n        # find the index of the leftmost appearance of `target`. if it does not\n        # appear, return [-1, -1] early.\n        for i in range(len(nums)):\n            if nums[i] == target:\n                left_idx = i\n                break\n        else:\n            return [-1, -1]\n\n        # find the index of the rightmost appearance of `target` (by reverse\n        # iteration). it is guaranteed to appear.\n        for j in range(len(nums)-1, -1, -1):\n            if nums[j] == target:\n                right_idx = j\n                break\n\n        return [left_idx, right_idx]" ,
      "Transcript": "Student: Well, okay so the problem says to find the indices of the first and last position\nof an element in a sorted array is...\nStudent: I guess I'd first start with simply using a for loop and checking for the target value,\nas soon as we hit one then record the index as the start and end value. When we see a number after\nthis that is different then the end value is set to the previous start\nStudent: Oh wait looks like that didn't work...\nAssistant: The problem statement appears to ask for you to do this in log(n) time think about whether\nyour proposed code can meet this time complexity argument. Remember your current code is looping through all\nn elements of the array.\nStudent: Oh right, that means that the complexity must be n rather than log(n). I just need to not go through \nthe entire array... maybe early termination will do it!\nStudent: Oh wait... this isn't actually getting it to linear. Hmm, why..."
    },
    {
     "Current Code": "    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        lo = 0\\n        hi = len(nums) - 1\\n        ans = [-1, -1]\\n        targetmid = -1\\n        \\n        while lo <= hi:\\n            if nums[lo] == target:\\n                if ans[0] != -1 and lo <= ans[0]:\\n                    ans[0] = lo\\n                if ans[0] == -1:\\n                    ans[0] = lo\\n            if nums[hi] == target and hi >= ans[1]:\\n                ans[1] = hi\\n            \\n            mid = (lo + hi) // 2\\n\\n            if target < nums[mid]:\\n                hi = mid - 1\\n            elif target > nums[mid]:\\n                lo = mid + 1\\n            else: \\n                lo +=1\\n                hi -=1\\n        \\n        return ans\"" ,
      "Transcript": "Student: Well, okay so the problem says to find the indices of the first and last position\nof an element in a sorted array is...\nStudent: I guess I'd first start with simply using a for loop and checking for the target value,\nas soon as we hit one then record the index as the start and end value. When we see a number after\nthis that is different then the end value is set to the previous start\nStudent: Oh wait looks like that didn't work...\nAssistant: The problem statement appears to ask for you to do this in log(n) time think about whether\nyour proposed code can meet this time complexity argument. Remember your current code is looping through all\nn elements of the array.\nStudent: Oh right, that means that the complexity must be n rather than log(n). I just need to not go through \nthe entire array... maybe early termination will do it!\nStudent: Oh wait... this isn't actually getting it to linear. Hmm, why...\nAssistant: I see that you may be confused on what approach to take, think about what this will do in the worst case scenario. The code\nwill have to scan most if not all the array if the values are in the middle. You instead need to think of an algorithm that's already \nin log(n)\nStudent: Okay then, I will implement binary search since its actually log(n) as usual except that I'll keep track of the\nstart and end values via a clever choice of lo and hi\nStudent: I'm not entirely sure how to ensure that I can find the lowest target value after finding the first\nbut here's a first attempt that makes sense to me"
    },
    {
     "Current Code": "  def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \n        lower_bound = self.findBound(nums, target, True)\n        if (lower_bound == -1):\n            return [-1, -1]\n        \n        upper_bound = self.findBound(nums, target, False)\n        \n        return [lower_bound, upper_bound]\n        \n    def findBound(self, nums: List[int], target: int, isFirst: bool) -> int:\n        \n        N = len(nums)\n        begin, end = 0, N - 1\n        while begin <= end:\n            mid = int((begin + end) / 2)    \n            \n            if nums[mid] == target:\n                \n                if isFirst:\n                    if mid == begin or nums[mid - 1] < target:\n                        return mid\n\n                    end = mid - 1\n                else:\n                    \n                    if mid == end or nums[mid + 1] > target:\n                        return mid\n                    \n                    begin = mid + 1\n            \n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                begin = mid + 1\n        \n        return -1" ,
      "Transcript": "Student: Well, okay so the problem says to find the indices of the first and last position\nof an element in a sorted array is...\nStudent: I guess I'd first start with simply using a for loop and checking for the target value,\nas soon as we hit one then record the index as the start and end value. When we see a number after\nthis that is different then the end value is set to the previous start\nStudent: Oh wait looks like that didn't work...\nAssistant: The problem statement appears to ask for you to do this in log(n) time think about whether\nyour proposed code can meet this time complexity argument. Remember your current code is looping through all\nn elements of the array.\nStudent: Oh right, that means that the complexity must be n rather than log(n). I just need to not go through \nthe entire array... maybe early termination will do it!\nStudent: Oh wait... this isn't actually getting it to linear. Hmm, why...\nAssistant: I see that you may be confused on what approach to take, think about what this will do in the worst case scenario. The code\nwill have to scan most if not all the array if the values are in the middle. You instead need to think of an algorithm that's already \nin log(n)\nStudent: Okay then, I will implement binary search since its actually log(n) as usual except that I'll keep track of the\nstart and end values via a clever choice of lo and hi\nStudent: I'm not entirely sure how to ensure that I can find the lowest target value after finding the first\nbut here's a first attempt that makes sense to me\nAssistant: While this appears to be code that implements binary search, it does not accurately deal with\nhow to find the left or right most of the target value. For example if you find the target, you increment lo meaning\nyou'll never see if there is a target value earlier in the array. See if there is a simpler more systematic way\nto find the bounds\nStudent: I see what you mean I guess. So maybe I can look at this problem as simply defining my targets\nas the first and last targets and performing 2 separate binary searches with updated target checks\nStudent: Here! That should do it I think"
    }
  ]
}